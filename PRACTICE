ACTIVITY 1
<#1.Ensure that you have the latest copy of help by updating your help system.


Update-help -Force -ErrorAction SilentlyContinue 

#2.Which cmdlets deal with the viewing/manipulating of processes?

Get-Command *process                                                                                                                                           
Function        Get-AppvVirtualProcess                             1.0.0.0    AppvClient                                                                                                                                         
Function        Start-AppvVirtualProcess                           1.0.0.0    AppvClient                                                                                                                                         
Cmdlet          Debug-Process                                      3.1.0.0    Microsoft.PowerShell.Management                                                                                                                    
Cmdlet          Enter-PSHostProcess                                3.0.0.0    Microsoft.PowerShell.Core                                                                                                                          
Cmdlet          Exit-PSHostProcess                                 3.0.0.0    Microsoft.PowerShell.Core                                                                                                                          
Cmdlet          Get-Process                                        3.1.0.0    Microsoft.PowerShell.Management                                                                                                                    
Cmdlet          Start-Process                                      3.1.0.0    Microsoft.PowerShell.Management                                                                                                                    
Cmdlet          Stop-Process                                       3.1.0.0    Microsoft.PowerShell.Management                                                                                                                    
Cmdlet          Wait-Process                                       3.1.0.0    Microsoft.PowerShell.Management 


#3.Display a list of services installed on your local computer.


Get-Service , get-wmiobject


#4.What cmdlets are used to write or output objects or text to the screen?


write-host echo , 


#5.What cmdlets can be used to create, modify, list, and delete variables?

get-variable , Set-Variable  get-childitem variable:* ,  Remove-Variable


#6.What cmdlet can be used, other than Get-Help, to find and list other cmdlets?

get-command


#7.Find the cmdlet that is used to prompt the user for input.

read-host

#>
_____________________________________________________________________________________________________________________________
ACTIVITY 2 
<#Display a list of running processes.

get-process , ps ,get-wmiobject

Display a list of all running processes that start with the letter "s".

 get-process -name s*

Find the cmdlet and its purpose for the following aliases:


gal

--$alias:gal
Get-Alias

dir

$alias:dir
Get-ChildItem

echo

 $alias:echo
Write-Output

?       get-alias -name ?

 ? -> Where-Object
%

 % -> ForEach-Object  

ft

$alias:ft
Format-Table



Display a list of Windows Firewall Rules.

Get-NetFirewallRule


Create a new alias called "gh" for the cmdlet "Get-Help"

Set-Alias gh Get-Help
#>
_____________________________________________________________________________________________________________________________
ACTIVITY 3:
<#
1.Create a variable called "var1" that holds a random number between 25-50.

$var1 = (get-random -Maximum 50 -Minimum 25)

2.Create a variable called "var2" that holds a random number between 1-10.

$var2 = (get-random -Maximum 10 -Minimum 1)

3.Create a variable called "sum" that holds the sum of var1 and var2.


 $sum = ( $var1+ $var2)

4.Create a variable called "sub" that holds the difference of var1 and var2.

$sub = ($var1-$var2)

5.Create a variable called "prod" that holds the product of var1 and var2.
$prod = ($var1 * $var2)

6.Create a variable called "quo" that holds the quotient of var1 and var2.
$quo = ($var1 / $var2)

7.Replace the variables in text with their values in the following format:


"var1" + "var2" = "sum"


Write-Host "$var1" + "$var2" = "$sum"


8.Replace the variables in text with their values in the following format:



 write-host "$var1" - "$var2" = "$sub"





9.Replace the variables in text with their values in the following format:



write-host "$var1" * "$var2" = "$prod"





10.Replace the variables in text with their values in the following format:



 write-host "$var1" / "$var2" = "$quo"

#>
_____________________________________________________________________________________________________________________________
ACTIVITY 4:
<#

Create an array containing a range with a random starting and stopping point.  The starting point will be a random number from -10 through 0.
The ending point will be a random number from 1 through 20.
For example, if the first random number is -3, and the second random number is 2, your array will be -3, -2, -1, 0, 1, 2
Create a variable that contains the contents of the array in reverse
Using the above example, your reversed array will be 2, 1, 0, -1, -2, -3


$ARRAY = (get-random -minimum -10 -maximum 0)..(get-random -Minimum 1 -Maximum 20)
$rev = $array[($array.length-1)..0] 

#>

_____________________________________________________________________________________________________________________________
ACTIVITY 5:
Create two empty hash tables with the following names:
employee1
employee2
Using the following table of key-value pairs, apply each key-value to the empty hash tables.

First   mary                   john
Last    hopper                 williams
ID      001                    002
Job   software developer       Web Developer

Now add a new key called Username which holds a contraction of the employeeâ€™s first initial then last name then ID. (i.e. mhopper001).
Mary got promoted to "Software Lead" so the job key for Mary needs to be changed to "Software Lead"
Create a new hash table called "employee3" that contains the following values with the respective keys.

first     last     id      job

alex       moran    003     Software Developer

 add a new key called "status" that loads the values:

 mary                john            alex

management           intermediate    Entry level

Make sure you use both dot notation and square brackets to manipulate your hash tables.


$employee1 = [ordered]@{ first="Mary" ; last="Hopper" ; ID="001" ; Job="Software Developer"}
$employee2 = [ordered]@{ first="John" ; last="Williams" ; ID="002" ; Job="Web Developer"}
$employee1.add("Username","mhopper001")
$employee2.add("Username","jwilliams002")
$employee1.Job="software Lead"
$employee3 = [ordered]@{ first="Alex" ; last="Moran" ; ID="003" ; Job="Software Developer"}
$employee1.add("Status","Management")
$employee2.add("Status","Intermediate")
$employee3.add("Status","Entry Level")
$employee3.add("Username","amoran003")

 OR

$employee1 = [ordered]@{ first="Mary" ; last="Hopper" ; id="001" ; job="Software Developer ;username="mhopper001" ; status="management"}
$employee2 = [ordered]@{ first="John" ; last="Williams" ; id="002" ; job="Web Developer"  ; username="jwilliams002" ;status="intermediate" }
$employee3 = [ordered]@{ first="Alex" ; last="Moran" ; id="003" ; job="Software Developer" ; username="amoran003" ; status="entry level"}




_______________________________________________________________________________________________________________________________________________
ACTIVITY 6


Display the start time of the earliest and latest running processes
get-process | where-object {$_.Starttime} | measure-object -property starttime -minimum -maximum | select-object -property name, minimum, maximum

Identify a cmdlet that returns the current date and time then using this cmdlet and Select-object, display only the current day of the week

get-date | select-object DayofWeek

(get-date).dayofweek

Identify a cmdlet that displays a list of installed hotfixes.


get-hotfix

Extend the expression to sort the list by install date, and display only the install date and hotfix ID.

Get-HotFix |Sort-Object -Property InstalledOn |Select-Object installedon,  HOTFIXID

Extend the expression further, but this time sort by description, include description, hotfix ID, and install Date.

Get-HotFix | Sort-Object description | Select-Object description, HotFixID, InstalledOn


___________________________________________________________________________________________________________________________________________________
Create a custom object that contains information about the host system using the following:
Win32_ComputerSystem
Win32_BIOS
Win32_OperatingSystem
Win32_LogicalDisk
Use the cmdlet Get-WmiObject to obtain the needed information

ComputerName    : DESKTOP-5KJDVS2
OperatingSystem : Microsoft Windows 10 Pro
Version         : 10.0.17134
Manufacturer    : Dell Inc.
Disks           : {\\DESKTOP-                          5KJDVS2\root\cimv2:Win32_LogicalDisk.DeviceID="C:",
                  \\DESKTOP-5KJDVS2\root\cimv2:Win32_LogicalDisk.DeviceID="D:"}
----
__-----------------------------------____---------------------------------_____-------------------------_____--_-_-_-_-_-


$comp = new-object computer
$cname = Get-WmiObject win32_computersystem | Select-Object -ExpandProperty name
$OS = Get-WmiObject win32_operatingsystem  | Select-Object -ExpandProperty caption
$Ver = Get-WmiObject win32_operatingsystem  | Select-Object -ExpandProperty version
$manuf = Get-WmiObject win32_BIOS  | Select-Object -ExpandProperty manufacturer
$disks = Get-WmiObject win32_logicaldisk  | Select-Object -ExpandProperty path |Select-Object path

Add-Member -MemberType NoteProperty -name ComputerName: -Value $cname -InputObject $comp
Add-Member -MemberType NoteProperty -name OperatingSystem: -Value $OS -InputObject $comp
Add-Member -MemberType NoteProperty -name Version: -Value $Ver -InputObject $comp
Add-Member -MemberType NoteProperty -name Manufacturer: -Value $manuf -InputObject $comp
Add-Member -MemberType NoteProperty -name Disks: -Value $disks -InputObject $comp
$comp | fl


OR


$compi = New-Object Object
Add-Member -MemberType NoteProperty -name Version -value (Get-WmiObject Win32_OperatingSystem).version -InputObject $compi
Add-Member -MemberType NoteProperty -name OperatingSystem -value (Get-WmiObject Win32_operatingsystem).caption -InputObject $compi
Add-Member -MemberType NoteProperty -name Manufacturer -value (Get-WmiObject Win32_BIOS).manufacturer -InputObject $compi
Add-Member -MemberType NoteProperty -name Disks -Value (get-wmiobject Win32_LogicalDisk) -InputObject $compi
Add-Member -MemberType NoteProperty -name ComputerName -value (Get-WmiObject Win32_Computer
System).name -InputObject $compi


#>

_______________________________________________________________________________________________________________________________________________


ACTIVITY 8:

<#
Find and extract the model number from the provided lines of text. If there isnâ€™t a model number then display to the user that a model number wasnâ€™t found
Check both lines for model numbers and report individually the line and model number if found.
$line1 = "Do you have model number: MT5437 for john.doe@sharklasers.com?"
$line2 = "What model number for john.doe@sharklasers.com?"
Exercise Criteria
Must use at least ONE comparison operator
Must use at least ONE If Condition OR Switch Statement
Reminder of options available
Switch Statement
If/IfElse/Else Condition
match, contains, in, -eq, -le, etcâ€¦â€‹
Comparison combinations
------------------------


$line1 = "Do you have model number: MT5437 for john.doe@sharklasers.com?"
$line2 = "What model number for john.doe@sharklasers.com?"
$patern = '[A-Za-z]{2}\d{2,5}'

switch($pattern) {
    {$line1 -match $_ } {
        $line1 -match $pattern |out-null
        $model = $Matches[0]
            "yes the model is $model" }
    {$line2 -match $_} {
        $line2 -match $pattern |out-null
        $model = $matches[0]
            "yes the model is $model"}
    {$line1 -notmatch $_} {
        "there is no model number in line1"}
    { $line2 -notmatch $_} {
        "there is no model number in line2"}
}
_________________________________________________________________________________________________________________________________________
ACTIVITY 9:
<#
ACTIVITY: Looping & Iteration
* Part 1
** Use an array to iterate and open the following
*** Notepad
*** MS Edge
*** MSpaint
** Query the processes
** Kill the processes from PowerShell
* Part 2
** Use an array to iterate and open the following
*** Notepad
*** MS Edge
*** MSpaint
** Query the processes
** Save the ProcessIDs to a text file called *_procs.txt_*
** Iterate through the ProcessIDs in the text file and kill them
* Part 3
** Use an array to iterate and open the following
*** Notepad
*** MS Edge
*** MSpaint
** Query the processes and display only the following information in order by process ID
*** Process ID
*** Process Name
*** The time the process started
*** The amount of time the process has spent on the processor
*** The amount of memory assigned to the process




#1 store elements in aray 
$procs = "notepad", "mspaint"

$procs | foreach-object { Start-Process $_ }

get-process 

$procs | foreach-object { Stop-Process -processname $_ }

#2

$file = "$pwd\procs.txt"
set-content -value $null $file
foreach($proc in $procs) {
start-process $proc
get-process | where-object {$_.name -like $proc} | foreach-object {add-content -path $file -value $_.id} }
#iterate throguh ids on procs.tct tp kill process.
Get-content $file | foreach-object{stop-process -id $_}
foreach($proc in $procs){
  get-process | where-object {$_.name -like $proc} | `
  format-table -property id, name, starttime, totalprocessortime, `
  virtualmemorysize, workingset64 }





  
$procs = "notepad", "mspaint"
Foreach ($process


#>

___________________________________________________________________________________________________________________
ACTIVITY 10:

<#


Write a function that returns the Ordinal date of the current date.
Example
PS> Get-OrdinalDate
2020-36

function Ordate{
$year =(get-date).year
$day=(get-date).dayofyear
write-host "$year-$day"
}
Orddate


Create a function that takes a number(n) as an argument and returns the square(n^2) of the number.
Example
PS> Get-SquareNum 10
100

function SirSquarey([int]$numero)
{
    $output = $numero * $numero 
    return $output
}




Create a function that takes three (3) arguments and returns the product of the arguments.
Example
PS> Get-Product 5 5 5
125


$arg1 = [int](Read-Host)
$arg2 = [int](Read-Host)
$arg3 = [int](Read-Host)
$arguments = ($arg1 * $arg2 * $arg3)
 return $arguments
  
or 
  
function multiplexy ($1, $2, $3) {$1 * $2 * $3 }

#>

___________________________________________________________________________________________________________________

ACTIVITY 11:

<#
1.Create a function that takes two(2) integer values, ```$a``` and ```$b```, that are the lengths of two(2) legs of a right triangle and returns the length of the hypotenuse.
[IMPORTANT]
====
Use the Pythagorean Theorem (a^2^ + b^2^ = c^2^) to find the value of the hypotenuse.


function pythyguy {
param(
    [parameter(mandatory=$true)][int]$a,
    [parameter(mandatory=$true)][int]$b
    ) 
     $c = ($a * $a) + ($b * $b)
     [math]::sqrt($c)
     }

      or 
function pythyguy ($a,$b){

$c = ($a * $a) + ($b * $b)
     [math]::sqrt($c)
}



====
2. Create a function that takes two(2) values, ```$a``` and ```$b```, as two(2) angles in degrees of a triangle. Return the value of the missing angle.
[IMPORTANT]
====
All angles of a triangle add up to be 180 degrees



function lengthydude {
param(
[parameter(mandatory=$true)][int]$a,
    [parameter(mandatory=$true)][int]$b
    ) 
    $angledboi= 180- ($a +$b )
    Write-Output $angledboi

}

OR
function lengthydude ($a, $b) {
 $angledboi= 180- ($a +$b )
    Write-Output $angledboi

}



====
3. Create a function that takes the following as mandatory parameters:
** First Name
** Last Name
** Age
** Weight in pounds(lbs)
and returns the information in a hash table using the keys: first, last, age, and weight with the ```weight``` value converted to kilograms(kg) rounded to the nearest whole number
[IMPORTANT]
====
One(1) Kilogram(Kg) = 2.2 pounds(lbs)
----------------------------------------------------


function weightedboi {
    param(
     [Parameter(Mandatory=$true)]
     $Fname,
     [Parameter(Mandatory=$true)]
     $Lname,
     [Parameter(Mandatory=$true)]
     $Age,
     [Parameter(Mandatory=$true,helpmessage="input weight in pounds")]
     $Weight
     )

     $getfit = [math]::Round($Weight / 2.2)

     Write-Output  "Good Morning $Fname $Lname"
     Write-Output  "$Age years old i see"
     Write-Output  "your weight converted to KG is  $getfit"


}


#>

__________________________________________________________________________________________________________________

__________________________________________________________________________________________________________________________________________________________________

# Activity #12: Advance Function Parameters

# Create an advanced function using Begin, Process, and End, that takes two(2) arguments. 
# The first argument being an array of at least ten(10) integers and the second argument being a single integer. 
# Search the array argument for every occurrence of the single integer argument then return the sum of all elements in 
# the array excluding every occurrence of the single integer argument.
#
# Example:
#         PS> Get-MultiSums @(1,2,3,4,5,6,7,8,9,10) 5
#         50

<#
function Find-Sums ([array]$array, [int]$nums) {
    Begin {
          $sum = 0
    }
    Process {        
        ForEach ($numb in $array) {
            if ($numb -ne $nums) {
                 $sum = $sum+$numb
            }
        }
    }
    End {
             Write-Host $sum
    }
}
find-sums @(1,2,3,4,5,6,7,8,9,10) 5
#>

# -OR-
# Checks to see if the array has at least 10 values and that the number to skip is in the array
<#
function Find-Sums ([array]$array, [int]$nums) {
    Begin {
          $sum= 0
    }
    Process {
        while ($array.count -lt 10 ) {
            [int]$more = read-host -prompt "Enter an integer"
            $array += $more
            }
        if ($array -notcontains $nums) {
            throw "Enter an integer within the array"
        }           
        ForEach ($numb in $array) {
            if ($numb -ne $nums) {
                 $sum = $sum+$numb
            }
        }

    }
    End {           
            Write-Host $sum
        }
    }
find-sums @(1,2,3,4,5,6,7) 1
#>

# Create an advanced function using Begin, Process, End, that prompts the user to enter the names of three(3) U.S. States 
# then returns the names of the states in the order of longest name to shortest name and the amount of characters in each name.
#
# Example:
#         PS> Get-LongestName
#         Georgia: 7
#         Idaho: 5
#         Utah: 4


#Using an Array to hold the values
<#
function Get-StateNameLength {
    #param ($a,$b,$c)
    Begin {
        $a = Read-Host "Enter a State name"
        $b = Read-Host "Enter a second State name"
        $c = Read-Host "Enter a third State name"
        $statearray=(@($a;$b;$c) | sort {$_.length} -Descending)
    }
    Process {
        foreach ($state in $statearray){
            $len= $state.Length
            Write-Output ""$state": $len"
        }
    }
}
#>

# -OR-
# Using a Hash Table to store the Values
<#
function states ($st1,$st2,$st3){
    BEGIN {
        if ([string]::IsNullOrEmpty($st1)) {
            $st1 = Read-Host 'First State '
        }
        if ([string]::IsNullOrEmpty($st2)) {
            $st2 = Read-Host 'Second State '
        }
        if ([string]::IsNullOrEmpty($st3)) {
            $st3 = Read-Host 'Third State '
        }
        #$stl1 = $st1.Length 
        #$stl2 = $st2.Length
        #$stl3 = $st3.Length
    }
    PROCESS{
        $states = @{ $st1 = $st1.length; $st2 = $st2.Length; $st3 = $st3.Length}
        #$states = @{ $st1 = $stl1; $st2 = $stl2; $st3 = $stl3}
    }
    END { 
        $states.GetEnumerator() | sort -Property Value -Descending | Format-Table -HideTableHeaders 
    }
}
#>

# -OR-
# Using a VBScript Pop-up
<#
function USState-Lengths {
    Begin {
        $counter=1
        $US_States= @()
          }
    Process {
             while ($counter -ge 1 -and $counter -le 3)
                   {
                       [void][Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic')
                            $title = "Choose a US State"
                            $msg = "Enter your US State #${counter}:"
                            $text = [Microsoft.VisualBasic.Interaction]::InputBox($msg, $title)
                       $US_State=$text
                       $US_States += $US_State 
                       $counter +=1
                   }
             foreach ($state in $US_States) {
                if ($state.length -eq 0) {
                        throw 'Unable to accept a value of $null. Re-run function and enter a US State(s)'
                        }
                }
            }
    End {
        $Order= $US_States | Sort-Object -Property Length -Descending
             foreach ($state in $Order) 
                    {
                        Write-Host ${state}:  ${state}.Length
                    }
        }
}

USState-Lengths
#>

______________________________________________________________________________________________________________________________________________________________
# Activity #11: Function Parameters

# Create a function that takes two (2) integer values, '$a' and '$b', that are the lengths of two (2) legs
# of a right triangle and returns the hypotenuse
#
# Use the Pythagorean Theorem of (a^2 + b^2 = c^2) to find the value of the hypotenuse

<#
function Find-Hypotenuse($a,$b) {
    $c2= ($a * $a) + ($b * $b)  
    [math]::Sqrt($c2)
    }
#>

# -OR-
# Validates sides are entered and are not blank/null
<#
function Find-Hypotenuse {
    param (
        [parameter(mandatory=$true,helpmessage="Side one of triangle")]
        $a, 
        [parameter(mandatory=$true,helpmessage="Side two of triangle")]
        $b
        )
    if ([string]::IsNullOrEmpty($a)) {
        while ([string]::IsNullOrEmpty($a)) {
            $a=read-host -Prompt "Enter a value for Side1"
        }
    }
    if ([string]::IsNullOrEmpty($b)) {
        while ([string]::IsNullOrEmpty($b)) {
            $b=read-host -Prompt "Enter a value for Side2"
        }
    }
    $c2= ([math]::Pow($a,2)) + ([math]::Pow($b,2))
    [math]::Sqrt($c2)
}
#>

# Create a function that takes two (2) values, '$a' and '$b', as two (2) angles in degrees of a triangle.
# Return the value of the missing angle

<#
function get-angle($a,$b){
    $angle = 180 - ($a + $b)
    Write-Host $angle
}
#>

# -OR-
# Validates this is a real triangle
<#
function Find-Angle ($ang1,$ang2) {
    $ang3= 180 - ($ang1 + $ang2)
    if ($ang3 -gt 0 -AND $ang3 -lt 180) {
       write-host "Missing angle is $ang3 degrees" 
       }
       Else {
       Write-Host "This is not a real triangle"
       }
}

Find-Angle 30 90
#>

# Create a function that takes the following as mandatory parameters:
#  -First Name
#  -Last Name
#  -Age
#  -Weight in pounds (lbs)
# Return the information in a hash table using the keys: 'first', 'last', 'age', and 'weight'. 
#  -The weight value returned shall be converted to kilograms (kg) and rounded to the nearest whole number

<#
function Display-PersInfo {
   param (
        [Parameter(Mandatory=$True, Position=0, HelpMessage="Type in your First Name")]
            [string]$Fname,
        [Parameter(Mandatory=$True, Position=1, HelpMessage="Type in your Last Name")]
            [string]$Lname,
        [Parameter(Mandatory=$True, Position=2, HelpMessage="Type in your Age")]
            [ValidateRange(0,120)]
            [int]$Age,
        [Parameter(Mandatory=$True, Position=3, HelpMessage="Type in your Weight in lbs")]
            [ValidateRange(0,750)]
            [int]$Weight
         )
    $KgWeight=[math]::Round($Weight / 2.2)
    $Display= [ordered]@{Fname="$Fname"; Lname="$Lname"; Age="$Age"; Weight="$KgWeight kgs"}
    Write-Output $Display
}
#>

_____________________________________________________________________________________________________________________________________________________________


# Activity #10: Creating Functions

# Write a function that returns the Ordinal date of the current date
# Example:
#         PS> Get-OrdinalDate
#         2022-36

<#
function Retrieve-OrdinalDate {
    $day=(get-date).DayOfYear
    $year=(get-date).Year
    write-host "$year-$day"
}
Retrieve-OrdinalDate
#>

# Create a function that takes a number(n) as an argument and returns the square(n^2) of the number 
# Example:
#         PS> Get-SquareNum 10
#         100

<#
function Number-Squared([int]$Number) {
    $Number * $Number
    
}
Number-Squared 6
#>

# -OR-
# Using .Net Casting
<#
function Number-Squared([int]$Number) {
    [math]::Pow($number,2)
}
Number-Squared 9
#>

# Create a function that takes three (3) arguments and returns the product of the arguments
# Example:
#         PS> Get-Product 5 5 5
#         125

<#
function Find-Product($Number1,$Number2,$Number3) {
    $Product= $Number1 * $Number2 * $Number3
    Write-Host $Product
}
Find-Product 2 4 6
#>

_________________________________________________________________________________________________________________________________________________________________


# Activity #09: Looping & Iteration

# Part 1
# Use an array to iterate and open the following:
#  -Notepad
#  -MS Edge
#  -MSPaint
# Query the Processes
# Kill the Processes

<#
# Array to start
$processes= "notepad", "msedge", "mspaint"
$processes | ForEach-Object {Start-Process $PSItem }

Query the Processes
#get-process $processes

# Stopping the Processes
$processes | % {Stop-Process -Name $_ }
#>

# Part 2
# Use an array to iterate and open the following:
#  -Notepad
#  -MS Edge
#  -MSPaint
# Query the Processes
# Save the ProcessIDs to a text file called 'procs.txt'
# Iterate through the process ids in the text file and kill them

<#
$processes= "notepad", "msedge", "mspaint"
$PIDs= "$env:HOMEPATH\Desktop\procs.txt"
$processes | ForEach-Object {Start-Process $PSItem }

sleep 1

ForEach ($process in $processes) {
    Get-Process | Where-Object { $PSItem.Name -like $process } |
    ForEach-Object { Add-Content $PIDs $_.Id} 
    }
sleep 1

Get-Content $PIDs | % {Stop-Process -Id $_ -ErrorAction SilentlyContinue }

sleep 1

remove-item $pids
#>


# Part 3
# Use an array to iterate and open the following:
#  -Notepad
#  -MS Edge
#  -MSPaint
# Query the Processes and display only the information in order by Process ID:
#  -Process ID
#  -Process Name
#  -Time the process started
#  -The amount of time the process has spent on the processor
#  -The amount of memory assigned to the process

<#
$processes= "notepad", "msedge", "mspaint"
$processes | ForEach-Object {Start-Process $PSItem }

ForEach ($process in $processes) {
    Get-Process | Where-Object { $PSItem.Name -like $process } |Format-Table -Property ID, Name, StartTime, TotalProcessorTime, WorkingSet64
    }
#>

___________________________________________________________________________________________________________________________________________________

# Activity #08: Comparisons and Conditions

# Find and extract the model number from the provided lines of text. If there isn't a model number, then display to the user that a
# model number was't found.
# Ensure to check both lines for the model number and report individually both the line and model number if found
#
# Use the following variables for your script:

$line1="Do you have model number: MO5437 for john.doe@sharklasers.com?"     
$line2="What model number for john.doe@sharklasers.com?"

# If/Else : Matches the Lines and spits model/no model
<#
$line1,$line2 | ForEach-Object { 
    if ($PSItem -match '[A-Z]{2}[0-9]{4}') { 
        Write-Host 'Model #'$Matches.Values
        } 
    else {
        Write-Host "Model Number Not Found"
        }
    }
#>

# -OR-
# If/Else : Matches the Model Number and spits both line number and model/no model
<# 
$line1,$line2 | ForEach-Object -Begin {$x=1 } -Process { 
    if ($PSItem -match '[A-Z]{2}[0-9]{4}') { 
        Write-Host -nonewline Line$x ; Write-Host ': Model #'$Matches.Values
        } 
    else {
        Write-Host -nonewline Line$x ; Write-Host ": Model Number Not Found"
        }
    $x++
    }
#>

# -OR-
# Switch :  Matches the Model Number and spits both line number and model/no model
<#
$regex = '[A-Z]{2}[0-9]{4}'
switch -Regex ($regex) {
    { $line1  } {
        if ($line1 -match $regex) {
            Write-Host "Line1: Model #"$Matches[0]
        }
        else {
             Write-Host "Line1: Model Number Not Found"
        }
    }
    { $line2 } {
        if ($line2 -match $regex) {
            Write-Host "Line2: Model #"$Matches[0]
        }
        else {
             Write-Host "Line2: Model Number Not Found"
        }
    }
}
#>
        _________________________________________________________________________________________________________________________________________________
        
        
        # Activity #07: Custom Objects

# Create a custom object that contains information about the host system using the following:
#  - Win32_ComputerSystem
#  - Win32_BIOS
#  - Win32_OperatingSystem
#  - Win32_LogicalDisk
# Use 'Get-WmiObject' or 'Get-CimInstance' to obtain the information
# 
# Output should look like the following:
#    Computername     :  Computer
#    OperatingSystem  :  Microsoft Server 2019
#    Version          :  10.0.23456
#    Manufacturer     :  Oracle
#    Disks            :  \\Computer\root\cimv2:Win32_LogicalDisk.DeviceID="A" , 
#                        \\Computer\root\cimv2:Win32_LogicalDisk.DeviceID="Z"

<#
$compinfo= Get-WmiObject Win32_ComputerSystem
$BIOSinfo= Get-WmiObject Win32_BIOS
$OSinfo= Get-WmiObject Win32_OperatingSystem
$Diskinfo= Get-WmiObject Win32_LogicalDisk
$SysInfo= New-object -TypeName psobject

$SysInfo | Add-Member -MemberType NoteProperty -Name Computername -Value $compinfo.Name
# -utilized : #compinfo | get-member
$SysInfo | Add-Member -MemberType NoteProperty -Name OperatingSystem -Value $OSinfo.Caption
# -utilized: $OSinfo | FL *
# -^^ same as $OSinfo | Format-List -Properties *
$SysInfo | Add-Member -MemberType NoteProperty -Name Version -Value $OSinfo.Version
$SysInfo | Add-Member -MemberType NoteProperty -Name Manufacturer -Value $BIOSinfo.Manufacturer
$SysInfo | Add-Member -MemberType NoteProperty -Name Disks -Value $Diskinfo.Path
$Sysinfo
#>


_________________________________________________________________________________________________________

# Activity #06: Pipeline

# Display the start time of the earliest and latest running processes

<#
Get-Process | Measure-Object -Property StartTime -Minimum -Maximum | Select-Object -Property Minimum, Maximum
#>

# -OR-
# Using Where-Object
<#
Get-Process | Where-Object {$_.StartTime} | Measure-Object -Property StartTime -Minimum -Maximum | Select-Object -Property Minimum, Maximum
#>

# Identify a cmdlet that returns the current date and time. Then using the same cmdlet and 'Select-object', display only the 
# current day of the week

<#
Get-Date
Get-Date | get-member
# get-member displays all the properties and methods of a command

Get-Date | Select-Object DayofWeek
#>

# Identify a cmdlet that displays a list of installed hotfixes

<#
Get-Hotfix
#>

# Extend the expression to sort the list by installation date, and display only the installation date and hotfix id

<#
Get-HotFix | Sort-Object -Property Installdate | Select-Object InstalledOn, HotFixID
#>

# Extend the expression further, but this time sort by description. Have it output only the description, hotfix id and installation date

<#
Get-HotFix | Sort-Object -Property Description | Select-Object InstalledOn, HotFixID, Description
#>

___________________________________________________________________________________________________________________________________________

# Activity #05: Hash Tables

# Create two empty hash tables with the following names:
#  -employee1
#  -employee2

<#
#Creating the emtpy hash table of employee1
$employee1 = [ordered]@{}

## '[ordered]' keeps the hash table key-values in the same order as they are defined
## when the hash table is declared/as more key-values are added

# Adding the keys and values for employee1
$employee1.First = "Mary"
$employee1["Last"] = "Hopper"
$employee1.ID = "001"
$employee1["Job"] = "Software Developer"

# Add keys and values for employee2

$employee2 = [ordered]@{ First = "John" ; Last = "Williams" ; ID = "002" ; Job = "Web Developer" }
#>

# Now add a new key called Username which holds a contraction of the employeeâ€™s 
# first initial then last name then ID. (i.e. mhopper001).

<#
$employee1.Username = "mhopper001"
$employee2["Username"] = "jwilliams002"
#>

# Mary got promoted to "Software Lead" so the job key for Mary needs to be 
# changed to "Software Lead"

<#
$employee1.Job = "Software Lead"
#>

# Create a new hash table called "employee3" that contains the following values
# with the respective keys.

<#
# Create employee3 
$employee3 = [ordered]@{}

# Add keys and values for employee3
$employee3.First = "Alex"
$employee3["Last"] = "Moran"
$employee3.add("ID","003")
$employee3.Username = "amoran003"
$employee3["Job"] = "Software Developer"
#>

# Add a new key called "Status" that holds the values:

<#
$employee1.Status = "Management"
$employee2["Status"] = "Intermediate"
$employee3.Status = "Entry Level"
#>
