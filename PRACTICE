ACTIVITY 1
<#1.Ensure that you have the latest copy of help by updating your help system.


Update-help -Force -ErrorAction SilentlyContinue 

#2.Which cmdlets deal with the viewing/manipulating of processes?

Get-Command *process                                                                                                                                           
Function        Get-AppvVirtualProcess                             1.0.0.0    AppvClient                                                                                                                                         
Function        Start-AppvVirtualProcess                           1.0.0.0    AppvClient                                                                                                                                         
Cmdlet          Debug-Process                                      3.1.0.0    Microsoft.PowerShell.Management                                                                                                                    
Cmdlet          Enter-PSHostProcess                                3.0.0.0    Microsoft.PowerShell.Core                                                                                                                          
Cmdlet          Exit-PSHostProcess                                 3.0.0.0    Microsoft.PowerShell.Core                                                                                                                          
Cmdlet          Get-Process                                        3.1.0.0    Microsoft.PowerShell.Management                                                                                                                    
Cmdlet          Start-Process                                      3.1.0.0    Microsoft.PowerShell.Management                                                                                                                    
Cmdlet          Stop-Process                                       3.1.0.0    Microsoft.PowerShell.Management                                                                                                                    
Cmdlet          Wait-Process                                       3.1.0.0    Microsoft.PowerShell.Management 


#3.Display a list of services installed on your local computer.


Get-Service , get-wmiobject


#4.What cmdlets are used to write or output objects or text to the screen?


write-host echo , 


#5.What cmdlets can be used to create, modify, list, and delete variables?

get-variable , Set-Variable  get-childitem variable:* ,  Remove-Variable


#6.What cmdlet can be used, other than Get-Help, to find and list other cmdlets?

get-command


#7.Find the cmdlet that is used to prompt the user for input.

read-host

#>
_____________________________________________________________________________________________________________________________
ACTIVITY 2 
<#Display a list of running processes.

get-process , ps ,get-wmiobject

Display a list of all running processes that start with the letter "s".

 get-process -name s*

Find the cmdlet and its purpose for the following aliases:


gal

--$alias:gal
Get-Alias

dir

$alias:dir
Get-ChildItem

echo

 $alias:echo
Write-Output

?       get-alias -name ?

 ? -> Where-Object
%

 % -> ForEach-Object  

ft

$alias:ft
Format-Table



Display a list of Windows Firewall Rules.

Get-NetFirewallRule


Create a new alias called "gh" for the cmdlet "Get-Help"

Set-Alias gh Get-Help
#>
_____________________________________________________________________________________________________________________________
ACTIVITY 3:
<#
1.Create a variable called "var1" that holds a random number between 25-50.

$var1 = (get-random -Maximum 50 -Minimum 25)

2.Create a variable called "var2" that holds a random number between 1-10.

$var2 = (get-random -Maximum 10 -Minimum 1)

3.Create a variable called "sum" that holds the sum of var1 and var2.


 $sum = ( $var1+ $var2)

4.Create a variable called "sub" that holds the difference of var1 and var2.

$sub = ($var1-$var2)

5.Create a variable called "prod" that holds the product of var1 and var2.
$prod = ($var1 * $var2)

6.Create a variable called "quo" that holds the quotient of var1 and var2.
$quo = ($var1 / $var2)

7.Replace the variables in text with their values in the following format:


"var1" + "var2" = "sum"


Write-Host "$var1" + "$var2" = "$sum"


8.Replace the variables in text with their values in the following format:



 write-host "$var1" - "$var2" = "$sub"





9.Replace the variables in text with their values in the following format:



write-host "$var1" * "$var2" = "$prod"





10.Replace the variables in text with their values in the following format:



 write-host "$var1" / "$var2" = "$quo"

#>
_____________________________________________________________________________________________________________________________
ACTIVITY 4:
<#

Create an array containing a range with a random starting and stopping point.  The starting point will be a random number from -10 through 0.
The ending point will be a random number from 1 through 20.
For example, if the first random number is -3, and the second random number is 2, your array will be -3, -2, -1, 0, 1, 2
Create a variable that contains the contents of the array in reverse
Using the above example, your reversed array will be 2, 1, 0, -1, -2, -3


$ARRAY = (get-random -minimum -10 -maximum 0)..(get-random -Minimum 1 -Maximum 20)
$rev = $array[($array.length-1)..0] 

#>

_____________________________________________________________________________________________________________________________
ACTIVITY 5:
Create two empty hash tables with the following names:
employee1
employee2
Using the following table of key-value pairs, apply each key-value to the empty hash tables.

First   mary                   john
Last    hopper                 williams
ID      001                    002
Job   software developer       Web Developer

Now add a new key called Username which holds a contraction of the employee’s first initial then last name then ID. (i.e. mhopper001).
Mary got promoted to "Software Lead" so the job key for Mary needs to be changed to "Software Lead"
Create a new hash table called "employee3" that contains the following values with the respective keys.

first     last     id      job

alex       moran    003     Software Developer

 add a new key called "status" that loads the values:

 mary                john            alex

management           intermediate    Entry level

Make sure you use both dot notation and square brackets to manipulate your hash tables.


$employee1 = [ordered]@{ first="Mary" ; last="Hopper" ; ID="001" ; Job="Software Developer"}
$employee2 = [ordered]@{ first="John" ; last="Williams" ; ID="002" ; Job="Web Developer"}
$employee1.add("Username","mhopper001")
$employee2.add("Username","jwilliams002")
$employee1.Job="software Lead"
$employee3 = [ordered]@{ first="Alex" ; last="Moran" ; ID="003" ; Job="Software Developer"}
$employee1.add("Status","Management")
$employee2.add("Status","Intermediate")
$employee3.add("Status","Entry Level")
$employee3.add("Username","amoran003")

 OR

$employee1 = [ordered]@{ first="Mary" ; last="Hopper" ; id="001" ; job="Software Developer ;username="mhopper001" ; status="management"}
$employee2 = [ordered]@{ first="John" ; last="Williams" ; id="002" ; job="Web Developer"  ; username="jwilliams002" ;status="intermediate" }
$employee3 = [ordered]@{ first="Alex" ; last="Moran" ; id="003" ; job="Software Developer" ; username="amoran003" ; status="entry level"}




_______________________________________________________________________________________________________________________________________________
ACTIVITY 6


Display the start time of the earliest and latest running processes
get-process | where-object {$_.Starttime} | measure-object -property starttime -minimum -maximum | select-object -property name, minimum, maximum

Identify a cmdlet that returns the current date and time then using this cmdlet and Select-object, display only the current day of the week

get-date | select-object DayofWeek

(get-date).dayofweek

Identify a cmdlet that displays a list of installed hotfixes.


get-hotfix

Extend the expression to sort the list by install date, and display only the install date and hotfix ID.

Get-HotFix |Sort-Object -Property InstalledOn |Select-Object installedon,  HOTFIXID

Extend the expression further, but this time sort by description, include description, hotfix ID, and install Date.

Get-HotFix | Sort-Object description | Select-Object description, HotFixID, InstalledOn


___________________________________________________________________________________________________________________________________________________
Create a custom object that contains information about the host system using the following:
Win32_ComputerSystem
Win32_BIOS
Win32_OperatingSystem
Win32_LogicalDisk
Use the cmdlet Get-WmiObject to obtain the needed information

ComputerName    : DESKTOP-5KJDVS2
OperatingSystem : Microsoft Windows 10 Pro
Version         : 10.0.17134
Manufacturer    : Dell Inc.
Disks           : {\\DESKTOP-                          5KJDVS2\root\cimv2:Win32_LogicalDisk.DeviceID="C:",
                  \\DESKTOP-5KJDVS2\root\cimv2:Win32_LogicalDisk.DeviceID="D:"}
----
__-----------------------------------____---------------------------------_____-------------------------_____--_-_-_-_-_-


$comp = new-object computer
$cname = Get-WmiObject win32_computersystem | Select-Object -ExpandProperty name
$OS = Get-WmiObject win32_operatingsystem  | Select-Object -ExpandProperty caption
$Ver = Get-WmiObject win32_operatingsystem  | Select-Object -ExpandProperty version
$manuf = Get-WmiObject win32_BIOS  | Select-Object -ExpandProperty manufacturer
$disks = Get-WmiObject win32_logicaldisk  | Select-Object -ExpandProperty path |Select-Object path

Add-Member -MemberType NoteProperty -name ComputerName: -Value $cname -InputObject $comp
Add-Member -MemberType NoteProperty -name OperatingSystem: -Value $OS -InputObject $comp
Add-Member -MemberType NoteProperty -name Version: -Value $Ver -InputObject $comp
Add-Member -MemberType NoteProperty -name Manufacturer: -Value $manuf -InputObject $comp
Add-Member -MemberType NoteProperty -name Disks: -Value $disks -InputObject $comp
$comp | fl


OR


$compi = New-Object Object
Add-Member -MemberType NoteProperty -name Version -value (Get-WmiObject Win32_OperatingSystem).version -InputObject $compi
Add-Member -MemberType NoteProperty -name OperatingSystem -value (Get-WmiObject Win32_operatingsystem).caption -InputObject $compi
Add-Member -MemberType NoteProperty -name Manufacturer -value (Get-WmiObject Win32_BIOS).manufacturer -InputObject $compi
Add-Member -MemberType NoteProperty -name Disks -Value (get-wmiobject Win32_LogicalDisk) -InputObject $compi
Add-Member -MemberType NoteProperty -name ComputerName -value (Get-WmiObject Win32_Computer
System).name -InputObject $compi


#>

_______________________________________________________________________________________________________________________________________________


ACTIVITY 8:

<#
Find and extract the model number from the provided lines of text. If there isn’t a model number then display to the user that a model number wasn’t found
Check both lines for model numbers and report individually the line and model number if found.
$line1 = "Do you have model number: MT5437 for john.doe@sharklasers.com?"
$line2 = "What model number for john.doe@sharklasers.com?"
Exercise Criteria
Must use at least ONE comparison operator
Must use at least ONE If Condition OR Switch Statement
Reminder of options available
Switch Statement
If/IfElse/Else Condition
match, contains, in, -eq, -le, etc…​
Comparison combinations
------------------------


$line1 = "Do you have model number: MT5437 for john.doe@sharklasers.com?"
$line2 = "What model number for john.doe@sharklasers.com?"
$patern = '[A-Za-z]{2}\d{2,5}'

switch($pattern) {
    {$line1 -match $_ } {
        $line1 -match $pattern |out-null
        $model = $Matches[0]
            "yes the model is $model" }
    {$line2 -match $_} {
        $line2 -match $pattern |out-null
        $model = $matches[0]
            "yes the model is $model"}
    {$line1 -notmatch $_} {
        "there is no model number in line1"}
    { $line2 -notmatch $_} {
        "there is no model number in line2"}
}
_________________________________________________________________________________________________________________________________________
ACTIVITY 9:
<#
ACTIVITY: Looping & Iteration
* Part 1
** Use an array to iterate and open the following
*** Notepad
*** MS Edge
*** MSpaint
** Query the processes
** Kill the processes from PowerShell
* Part 2
** Use an array to iterate and open the following
*** Notepad
*** MS Edge
*** MSpaint
** Query the processes
** Save the ProcessIDs to a text file called *_procs.txt_*
** Iterate through the ProcessIDs in the text file and kill them
* Part 3
** Use an array to iterate and open the following
*** Notepad
*** MS Edge
*** MSpaint
** Query the processes and display only the following information in order by process ID
*** Process ID
*** Process Name
*** The time the process started
*** The amount of time the process has spent on the processor
*** The amount of memory assigned to the process




#1 store elements in aray 
$procs = "notepad", "mspaint"

$procs | foreach-object { Start-Process $_ }

get-process 

$procs | foreach-object { Stop-Process -processname $_ }

#2

$file = "$pwd\procs.txt"
set-content -value $null $file
foreach($proc in $procs) {
start-process $proc
get-process | where-object {$_.name -like $proc} | foreach-object {add-content -path $file -value $_.id} }
#iterate throguh ids on procs.tct tp kill process.
Get-content $file | foreach-object{stop-process -id $_}
foreach($proc in $procs){
  get-process | where-object {$_.name -like $proc} | `
  format-table -property id, name, starttime, totalprocessortime, `
  virtualmemorysize, workingset64 }





  
$procs = "notepad", "mspaint"
Foreach ($process


#>

___________________________________________________________________________________________________________________
ACTIVITY 10:

<#


Write a function that returns the Ordinal date of the current date.
Example
PS> Get-OrdinalDate
2020-36

function Ordate{
$year =(get-date).year
$day=(get-date).dayofyear
write-host "$year-$day"
}
Orddate


Create a function that takes a number(n) as an argument and returns the square(n^2) of the number.
Example
PS> Get-SquareNum 10
100

function SirSquarey([int]$numero)
{
    $output = $numero * $numero 
    return $output
}




Create a function that takes three (3) arguments and returns the product of the arguments.
Example
PS> Get-Product 5 5 5
125


$arg1 = [int](Read-Host)
$arg2 = [int](Read-Host)
$arg3 = [int](Read-Host)
$arguments = ($arg1 * $arg2 * $arg3)
 return $arguments
  
or 
  
function multiplexy ($1, $2, $3) {$1 * $2 * $3 }

#>

___________________________________________________________________________________________________________________

ACTIVITY 11:

<#
1.Create a function that takes two(2) integer values, ```$a``` and ```$b```, that are the lengths of two(2) legs of a right triangle and returns the length of the hypotenuse.
[IMPORTANT]
====
Use the Pythagorean Theorem (a^2^ + b^2^ = c^2^) to find the value of the hypotenuse.


function pythyguy {
param(
    [parameter(mandatory=$true)][int]$a,
    [parameter(mandatory=$true)][int]$b
    ) 
     $c = ($a * $a) + ($b * $b)
     [math]::sqrt($c)
     }

      or 
function pythyguy ($a,$b){

$c = ($a * $a) + ($b * $b)
     [math]::sqrt($c)
}



====
2. Create a function that takes two(2) values, ```$a``` and ```$b```, as two(2) angles in degrees of a triangle. Return the value of the missing angle.
[IMPORTANT]
====
All angles of a triangle add up to be 180 degrees



function lengthydude {
param(
[parameter(mandatory=$true)][int]$a,
    [parameter(mandatory=$true)][int]$b
    ) 
    $angledboi= 180- ($a +$b )
    Write-Output $angledboi

}

OR
function lengthydude ($a, $b) {
 $angledboi= 180- ($a +$b )
    Write-Output $angledboi

}



====
3. Create a function that takes the following as mandatory parameters:
** First Name
** Last Name
** Age
** Weight in pounds(lbs)
and returns the information in a hash table using the keys: first, last, age, and weight with the ```weight``` value converted to kilograms(kg) rounded to the nearest whole number
[IMPORTANT]
====
One(1) Kilogram(Kg) = 2.2 pounds(lbs)
----------------------------------------------------


function weightedboi {
    param(
     [Parameter(Mandatory=$true)]
     $Fname,
     [Parameter(Mandatory=$true)]
     $Lname,
     [Parameter(Mandatory=$true)]
     $Age,
     [Parameter(Mandatory=$true,helpmessage="input weight in pounds")]
     $Weight
     )

     $getfit = [math]::Round($Weight / 2.2)

     Write-Output  "Good Morning $Fname $Lname"
     Write-Output  "$Age years old i see"
     Write-Output  "your weight converted to KG is  $getfit"


}


#>

__________________________________________________________________________________________________________________

ACTIVITY 12:
<#
Create an advanced function using Begin, Process, and End, that takes 
two(2) arguments. The first argument being an array of at least ten(10)
integers and the second argument being a single integer. Search the array argument for every occurrence
of the single integer argument then return the sum of all elements
in the array excluding every occurrence 
of the single integer argument
PS> get-multisum @(1,2,3,4,5,6,7,8,9,10) 5
50

function Find-sums ([array]$array,[int]$nums) {
Begin {
        sum = 0
    }
    process {
    ForEach ($numb in $array) {
        if ($numb - ne $nums) {
            $sums = $sum+$numb

            }
         }
    }
End {
        write-host $sum
    }
}






create an advanced function using Begin, Process, End, that prompts the user to enter the names of three(3) U.S.
 States then returns the names of the states in the order of longest name to shortest name and the amount of
  characters in each name.
PS> Get-LongestName
Georgia: 7
Idaho: 5
Utah: 4




